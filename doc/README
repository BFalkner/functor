Functor provides pattern-based function and method dispatch for Ruby. To use it in a class:

  class Repeater
    attr_accessor :times
    include Functor::Method
    functor( :repeat, Integer ) { |x| x * @times }
    functor( :repeat, String ) { |s| [].fill( s, 0..@times ).join(' ') }
  end

  r = Repeater.new
  r.times = 5
  r.repeat( 5 )   # => 25
  r.repeat( "-" ) # => "- - - - -"
  r.repeat( 7.3 ) # => ArgumentError!

Warning: This defines a class instance variable @__functors behind the scenes as a side-effect. Also, although inheritance works within a functor method, super does not. To call the parent method, you need to call it explicitly using the #functors class method, like this:

  A.functors[ :foo ].apply( self, 'bar' )

You can also define Functor objects directly:

  fib = Functor.new do
    given( 0 ) { 0 }
    given( 1 ) { 1 }
    given( 2..10000 ) { |n| self.call( n - 1 ) + self.call( n - 2 ) }
  end
  
You can use functors directly with functions taking a block like this:

  [ *0..10 ].map( &fib )  # => [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
  
You can call a functor as a method using #apply:

  fun.apply( obj, 7 )
  
which is actually how the method dispatch is implemented.

Arguments are matched first using === and then ==, so anything that supports these methods can be matched against. In addition, you may pass "guards," any object that responds to #call and which take and object (the argument) and return true or false. This allows you to do things like this:

  stripe ||= Functor.new do
    given( lambda { |x| x % 2 == 0 } ) { 'white' }
    given( lambda { |x| x % 2 == 1 } ) { 'silver' }
  end

which will return "white" and "silver" alternately for a sequence of numbers.